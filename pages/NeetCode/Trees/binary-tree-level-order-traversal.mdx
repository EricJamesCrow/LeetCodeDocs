# Binary Tree Level Order Traversal

**Difficulty:** <span style={{ color: '#F0AD4E', backgroundColor: '#FAEBCC', padding: '3px 5px', borderRadius: '4px' }}>Medium</span>

**Link:** https://leetcode.com/problems/binary-tree-level-order-traversal/

**Last updated:** 8/6/2023

## Description 

Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

**Example 1:**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="Tree" />


**Input:** `nums = [1,2,3,1]`  
**Output:** `true`  

**Example 2:**

**Input:** `nums = [1,2,3,4]`  
**Output:** `false`  

## Background

I learned how to implement Breadth First Search after reviewing the NeetCode solution for this problem.
I was able to solve other Tree problems that required Depth First Search on my own, but had to look up the solution for this one.
After reviewing NeetCode, I learned how to do BFS and found myself able to immediately solve seven other similar problems using this method,
which were:

* [Average of Levels in Binary Tree](./Additional_Problems/average-of-levels-in-binary-tree)
* [Find Largest Value in Each Tree Row](./Additional_Problems/find-largest-value-in-each-tree-row)
* [Find Bottom Left Tree Value](./Additional_Problems/find-bottom-left-tree-value)
* [Binary Tree Level Order Traversal II](./Additional_Problems/binary-tree-level-order-traversal-ii)
* [Binary Tree Zigzag Level Order Traversal](./Additional_Problems/binary-tree-zigzag-level-order-traversal)
* [Populating Next Right Pointers in Each Node](./Additional_Problems/populating-next-right-pointers-in-each-node)
* [Populating Next Right Pointers in Each Node II](./Additional_Problems/populating-next-right-pointers-in-each-node-ii)

## Solution

First, we check to see if root exists. If it does not, we return an empty array.
We then initialize a `queue` with `deque()` as well as an empty array named `result`.
We then append the `queue` with the `root` node.
We then start a while loop for while the queue is populated, in which we initialize an empty array named `current_result`.
We iterate through the queue, grabbing the the most current item using `queue.popleft()`, and we then append that item's value to the `current_result` array.
We then do two conditional checks for whether or not the current item has a left or right node. If it has either, it appends them to the queue.
At the end of the iteration for the while loop, we append all of the results collected from the for loop to the `result` array.
At the end of the loop, we return `result`.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        queue = deque()
        result = []

        queue.append(root)
        while queue:
            current_result = []
            for _ in range(len(queue)):
                curr = queue.popleft()
                current_result.append(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            result.append(current_result)
        return result
```


